<h3 class="page-header">Overview</h3>
<p>
	The OrderCloud API provides HTTP access to Four51's B2B eCommerce platform-as-a-service. With few exceptions, 
	the API adheres to a RESTful archtectural style. URIs, HTTP verbs, headers, payloads, and response codes all 
	follow consistent and predictable patterns.
</p>
<div class="row">
	<div class="col-sm-4">
		<h4><i class="fa fa-lock"></i> SSL Everywhere</h4>
		<p>API access is only allowed via HTTPS; connections on port 80 are refused entirely. This simplifies the token-based authentication.</p>
	</div>
	<div class="col-sm-4">
		<h4><i class="fa fa-file-code-o"></i> JSON Everywhere</h4>
		<p>UTF-8 encoded JSON is currently the only supported data format for both request and response payloads.</p>
	</div>
	<div class="col-sm-4">
		<h4><i class="fa fa-key"></i> OAuth 2</h4>
		<p>OrderCloud API authentication is based on <a href="https://tools.ietf.org/html/rfc6749">OAuth 2</a> and supports 2 different workflows; in OAuth terms, grant types.</p>
	</div>
</div>

<h3 class="page-header">Writable IDs</h3>
<p>Most resources that map to an entity of some sort (Orders, Users, Addresses, etc.) contain an ID that is optionally writable on creation or update. If you do not pass one, one will be auto-generated and returned in the response, and will be guaranteed to be unique. If you choose to pass an ID, you are responsible for ensuring uniqueness. Things that live under the context of a single Buyer need only be unique within that context. Things that are shared (such as products) must be unique within across the entire seller organization.</p>
<blockquote class="alert-info">Writable IDs can be extremely useful for back-office integrations. They can potentially eliminate the need for a mapping middleware layer.</blockquote>

<h3 class="page-header">Partial Resource Modification</h3>
<p>While the existing <code>PUT</code> method only allows a complete replacement of a resource we allow the <code>PATCH</code> method for partial updates.</p>
<p>Partial updates permit you to update certain attributes of a resource. For example, if you wish to update a <code>Product</code> description you only need to <code>PATCH</code> that single property.</p>

<h3 class="page-header">Extended Properties (xp)</h3>
<p>
	The reality of all enterprise platforms is the need to customize the data model.
	Ordercloud exposes the <code>{ xp: {} }</code> property on most resources allowing you to apply JSON objects.
	The JSON object can be as complex and deeply nested as necessary. Additionally, the xp property is available for filtering, sorting and searching
	in all pagination.
</p>
<div class="rounded-corners" readonly ui-ace="{
		onLoad: docs.setMaxLines,
		useWrapMode : true,
		theme:'twilight',
		mode: 'json',
		tabSize: '4',
		useSoftTabs: true,
		showPrintMargin: false,
		showGutter:false
	}" ng-model="docs.ReadmeScripts[2]"></div>
<h3 class="page-header">Error Handling</h3>
<p>For all unsuccessful requests, we attempt to return the <a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_Client_Error">most appropriate HTTP status in the 400 range</a>. Only when something goes terribly wrong on our end will you get a 500 response. And so long as our platform is responding (i.e. returing anything in the 4xx range or 500), you can count on the response body taking a standard shape:</p>
<div class="rounded-corners" readonly ui-ace="{
		onLoad: docs.setMaxLines,
		useWrapMode : true,
		theme:'twilight',
		mode: 'json',
		tabSize: '4',
		useSoftTabs: true,
		showPrintMargin: false,
		showGutter:false
	}" ng-model="docs.ReadmeScripts[1]"></div>


<h3 class="page-header">Getting Lists of Things</h3>
<p class="lead">Most endpoints that return a list support a robust set of querying parameters to custom taylor the results to your needs.</p>
<!--<br/>-->

<h4>Searching</h4>
<p>For open-ended, Google-esque searches, simply provide a search parameter:</p>
<pre>v1/buyers/xyz/users?search=smith</pre>

<p>The above example will return all results containing "smith", including "Smith", "Smithers", and "McSmith". The fields searched include <code>FirstName</code>, <code>LastName</code>, and <code>UserName</code>. (This of course varies from endpoint to endpoint. View each endpoints documentation for specific details.) You can optionally specify which fields are searched by providing a <code>searchOn</code> parameter:</p>
<pre>v1/buyers/xyz/users?search=smith&searchOn=LastName,UserName</pre>
<br/>

<h4>Sorting</h4>
<p>Each list endpoint has a default sort order. (See the Reference section for details). You may change this sort order with the sortBy parameter:</p>
<pre>v1/buyers/xyz/users?search=smith&sortBy=Email,ID</pre>

<p>Specify reverse sort order by preceding the column name with <code>!</code>:</p>
<pre>v1/buyers/xyz/users?search=smith&sortBy=!LastName</pre>
<br/>

<h4>Filtering</h4>
<p>Filtering is useful when you want to get a little more specific than what search offers. (You may, however, mix & match filtering with searching, sorting, etc. as much as you like.) Specify the field names directly as query parameters along with the desired values:</p>
<pre>v1/buyers/xyx/users?LastName=Smith&FirstName=John</pre>

<p>This will only return exact matches on users named "John Smith". Fuzzy matches are supported using the <code>*</code> wildcard character:</p>
<pre>v1/buyers/xyx/users?LastName=*Sm*th&FirstName=John*</pre>

<p>This will return both "John Smith" and "Johnny McSmooth". You can also use | as a logical OR:This will return both "John Smith" and "Johnny McSmooth". You can also use <code>|</code> as a logical OR:</p>
<pre>v1/buyers/xyx/users?LastName=Smith|Jo*&FirstName=Johnny</pre>

<p>This will return "John Smith", "Johnny Jones", and "John Johnson". Maybe you want "John Smith" but not "John Jones". You can negate your conditions by prefixing them with <code>!</code>, and logically AND them together by simply providing the same parameter multiple times:</p>
<pre>v1/buyers/xyx/users?LastName=!Smith&LastName=!Jones</pre>

<p>This will return all users <em>except</em> those with last name "Smith" or "Jones". Dates and numeric values support <code>></code> (greater than) and <code><</code> (less then) prefixes:</p>
<pre>v1/buyers/xyx/users?DateCreated=>01-01-2015</pre>

<p>For a more advanced example, let's say you want users whose ID is the range of 0 to 9 inclusive. Ranges are not directly supported, but you can use the existing features to achieve this. One way would be like this:</p>
<pre>v1/buyers/xyx/users?ID=0|1|2|3|4|5|6|7|8|9</pre>

<p>Of course that's not going to be feasible if the range is very large or you're dealing with floating-point numbers. A better way would be to leverage <code>></code> and <code><</code>, but we want the range to be <em>inclusive</em>, and there are no <code>>=</code> or <code><=</code> operators. We can however leverage the <code>!</code> operator:</p>
<pre>v1/buyers/xyx/users?ID=!<0&ID=!>9</pre>

<p>Here we're saying "give me all users whose ID is not less than 0 and not greater than 9", which is effectively equivalent to our 0-9 range.</p>
<br/>

<h4>XP Support</h4>
<p>For resources that support Extended Properties (<code>xp</code>), you can search, sort, and filter on those values, even if within a deep object graph, using dot notation:</p>
<pre>v1/buyers/xyx/users?xp.MoreInfo.Gender=f*</pre>
<br/>

<h4>Paging</h4>
<p>Lists are generally capped at 20 items by default. At that point paging kicks in. You can use the <code>page</code> and <code>pagesize</code> parameters to specify the page (starting at 1) and items per page (maximum of 100), respectively.</p>
<pre>v1/buyers/xyx/users?DateCreated=>01-01-2015</pre>
<br/>

<h4>Response Body</h4>
<p>Responses for most list endpoints contain an object wrapping an <code>Items</code> array, which contains the actual "things", and a <code>Meta</code> object containing useful count/paging metadata.</p>
<div class="rounded-corners" readonly ui-ace="{
		onLoad: docs.setMaxLines,
		useWrapMode : true,
		theme:'twilight',
		mode: 'json',
		tabSize: '4',
		useSoftTabs: true,
		showPrintMargin: false,
		showGutter:false
	}" ng-model="docs.ReadmeScripts[0]"></div>
<br/>

<p>Note that unlike the page parameter, <code>ItemRange</code> values are zero-based.</p>
<br/>

<h4>Performance Considerations</h4>
<p>Your data is highly indexed for fast retrieval using any of the methods above, including deep <code>xp</code> object graphs. However, there are a few things to keep in mind to keep things snappy for your users. Filters with lots of OR conditions or with values that start with the <code>*</code> wildcard character may be particularly performance sensitive. Of course, the larger the set of data, the more likely you are to notice any performance impact. It pays to know the data model well, and use grouping constructs like User Groups and Categories effectively.</p>


<h3 class="page-header">Other Conventions</h3>

<h4>Date Format</h4>
<p>Dates/times returned in the API are in UTC time and conform to <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. Example:</p>
<pre>2015-04-23T00:00:00.000Z</pre>
<br/>

<h4>Creating Things</h4>
<p>Resource creation is generally done via <code>POST</code> and, when successful, retuns a 201 (created) status, a Location header containing the URI of the created resource, and for convenience the full JSON representation (equivalent to <code>GET</code> on the new resource) in the body. For things that do not contain identity, such as relationships, <code>PUT</code> is used for creation. The rationale is that you don't need to care whether you're creating or updating in these cases; <code>PUT</code> is <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">idempotent </a> by definition, meaning it can be called multiple times without different outcomes.</p>
<br/>

<h4>Updating Things</h4>
<p>Some areas of the API (most notably Orders) support partial updates via <code>PATCH</code>. Other areas only support full updates via <code>PUT</code>, but shape of the response bodies generally match the shape of the request bodies in these cases, allowing for an easy <code>GET</code>/modify/<code>PUT</code> pattern. <code>PUT</code> and <code>PATCH</code> both return 200 (OK) when successful, along with the full JSON representation in the body.</p>
<br/>

<h4>Deleting Things</h4>
<p>Resource deletion is generally done via <code>DELETE</code> and, when successful, returns a 204 (no content) response and an empty body.</p>
<br/>
<hr/>
